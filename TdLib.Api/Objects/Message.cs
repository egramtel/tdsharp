using System;
using Newtonsoft.Json;

// REUSE-IgnoreStart
namespace TdLib
{
    /// <summary>
    /// Autogenerated TDLib APIs
    /// </summary>
    public static partial class TdApi
    {
        /// <summary>
        /// Describes a message
        /// </summary>
        public partial class Message : Object
        {
            /// <summary>
            /// Data type for serialization
            /// </summary>
            [JsonProperty("@type")]
            public override string DataType { get; set; } = "message";

            /// <summary>
            /// Extra data attached to the object
            /// </summary>
            [JsonProperty("@extra")]
            public override string Extra { get; set; }

            /// <summary>
            /// Message identifier; unique for the chat to which the message belongs
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("id")]
            public long Id { get; set; }

            /// <summary>
            /// Identifier of the sender of the message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("sender_id")]
            public MessageSender SenderId { get; set; }

            /// <summary>
            /// Chat identifier
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("chat_id")]
            public long ChatId { get; set; }

            /// <summary>
            /// The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("sending_state")]
            public MessageSendingState SendingState { get; set; }

            /// <summary>
            /// The scheduling state of the message; may be null if the message isn't scheduled
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("scheduling_state")]
            public MessageSchedulingState SchedulingState { get; set; }

            /// <summary>
            /// True, if the message is outgoing
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_outgoing")]
            public bool IsOutgoing { get; set; }

            /// <summary>
            /// True, if the message is pinned
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_pinned")]
            public bool IsPinned { get; set; }

            /// <summary>
            /// True, if the message was sent because of a scheduled action by the message sender, for example, as away, or greeting service message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_from_offline")]
            public bool IsFromOffline { get; set; }

            /// <summary>
            /// True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_saved")]
            public bool CanBeSaved { get; set; }

            /// <summary>
            /// True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("has_timestamped_media")]
            public bool HasTimestampedMedia { get; set; }

            /// <summary>
            /// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_channel_post")]
            public bool IsChannelPost { get; set; }

            /// <summary>
            /// True, if the message is a forum topic message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_topic_message")]
            public bool IsTopicMessage { get; set; }

            /// <summary>
            /// True, if the message contains an unread mention for the current user
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("contains_unread_mention")]
            public bool ContainsUnreadMention { get; set; }

            /// <summary>
            /// Point in time (Unix timestamp) when the message was sent; 0 for scheduled messages
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("date")]
            public int Date { get; set; }

            /// <summary>
            /// Point in time (Unix timestamp) when the message was last edited; 0 for scheduled messages
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("edit_date")]
            public int EditDate { get; set; }

            /// <summary>
            /// Information about the initial message sender; may be null if none or unknown
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("forward_info")]
            public MessageForwardInfo ForwardInfo { get; set; }

            /// <summary>
            /// Information about the initial message for messages created with importMessages; may be null if the message isn't imported
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("import_info")]
            public MessageImportInfo ImportInfo { get; set; }

            /// <summary>
            /// Information about interactions with the message; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("interaction_info")]
            public MessageInteractionInfo InteractionInfo { get; set; }

            /// <summary>
            /// Information about unread reactions added to the message
            /// </summary>
            [JsonProperty("unread_reactions", ItemConverterType = typeof(Converter))]
            public UnreadReaction[] UnreadReactions { get; set; }

            /// <summary>
            /// Information about fact-check added to the message; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("fact_check")]
            public FactCheck FactCheck { get; set; }

            /// <summary>
            /// Information about the message or the story this message is replying to; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("reply_to")]
            public MessageReplyTo ReplyTo { get; set; }

            /// <summary>
            /// If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("message_thread_id")]
            public long MessageThreadId { get; set; }

            /// <summary>
            /// Identifier of the Saved Messages topic for the message; 0 for messages not from Saved Messages
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("saved_messages_topic_id")]
            public long SavedMessagesTopicId { get; set; }

            /// <summary>
            /// The message's self-destruct type; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("self_destruct_type")]
            public MessageSelfDestructType SelfDestructType { get; set; }

            /// <summary>
            /// Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("self_destruct_in")]
            public double? SelfDestructIn { get; set; }

            /// <summary>
            /// Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("auto_delete_in")]
            public double? AutoDeleteIn { get; set; }

            /// <summary>
            /// If non-zero, the user identifier of the inline bot through which this message was sent
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("via_bot_user_id")]
            public long ViaBotUserId { get; set; }

            /// <summary>
            /// If non-zero, the user identifier of the business bot that sent this message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("sender_business_bot_user_id")]
            public long SenderBusinessBotUserId { get; set; }

            /// <summary>
            /// Number of times the sender of the message boosted the supergroup at the time the message was sent; 0 if none or unknown. For messages sent by the current user, supergroupFullInfo.my_boost_count must be used instead
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("sender_boost_count")]
            public int SenderBoostCount { get; set; }

            /// <summary>
            /// For channel posts and anonymous group messages, optional author signature
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("author_signature")]
            public string AuthorSignature { get; set; }

            /// <summary>
            /// Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums
            /// </summary>
            [JsonConverter(typeof(Converter.Int64))]
            [JsonProperty("media_album_id")]
            public long MediaAlbumId { get; set; }

            /// <summary>
            /// Unique identifier of the effect added to the message; 0 if none
            /// </summary>
            [JsonConverter(typeof(Converter.Int64))]
            [JsonProperty("effect_id")]
            public long EffectId { get; set; }

            /// <summary>
            /// True, if media content of the message must be hidden with 18+ spoiler
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("has_sensitive_content")]
            public bool HasSensitiveContent { get; set; }

            /// <summary>
            /// If non-empty, contains a human-readable description of the reason why access to this message must be restricted
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("restriction_reason")]
            public string RestrictionReason { get; set; }

            /// <summary>
            /// Content of the message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("content")]
            public MessageContent Content { get; set; }

            /// <summary>
            /// Reply markup for the message; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("reply_markup")]
            public ReplyMarkup ReplyMarkup { get; set; }
        }
    }
}
// REUSE-IgnoreEnd